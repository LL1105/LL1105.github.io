[{"categories":null,"contents":"Clean White Theme for Hugo CleanWhite is a clean, elegant, but fully functional blog theme for Hugo. Here is a live demo site using this theme.\nIt is based on huxblog Jekyll Theme and Clean Blog Jekyll Theme.\nThese two upstream projects have done awesome jobs to create a blog theme, what I\u0026rsquo;m doing here is porting it to Hugo, of which I like the simplicity and the much faster compiling speed. Some other features which I think could be useful, such as site search with algolia and proxy for Disqus access in China, have also been built in the CleanWhite theme. Other fancy features of upstream projects are not supported by this Hugo theme, I\u0026rsquo;d like to make it as simple as possible and only focus on blog purpose, at least for now. While I created this theme, I followed the Hugo theme best practice and tried to make every part of the template as a replaceable partial html, so it could be much easier for you to make your customization based on it.\nScreenshots Home Post Search Disqus Wechat Pay \u0026amp; Alipay Quick Start Go to the directory where you have your Hugo site and run:\n$ mkdir themes $ cd themes $ git clone https://github.com/zhaohuabing/hugo-theme-cleanwhite.git If your site is already a git project, you may want to choose to add the cleanwhite theme as a submodule to avoid messing up your existing git repository.\n$ mkdir themes $ git submodule add https://github.com/zhaohuabing/hugo-theme-cleanwhite.git themes/hugo-theme-cleanwhite Run Hugo Build-in Server Locally\n$ hugo serve -t hugo-theme-cleanwhite Now enter localhost:1313 in the address bar of your browser.\nIf you start from scratch, there is a working Hugo site configured with the CleanWhite theme in the exampleSite directory. You can use it as a starting point for your site.\nFor more information read the official setup guide of Hugo\nConfiguration First, let\u0026rsquo;s take a look at the config.toml. It will be useful to learn how to customize your site. Feel free to play around with the settings.\nComments The optional comments system is powered by Disqus. If you want to enable comments, create an account in Disqus and write down your shortname.\ndisqusShortname = \u0026#34;your-disqus-short-name\u0026#34; You can disable the comments system by leaving the disqusShortname empty.\nDisqus in China Disqus is inaccessible in China. To get it to work, we can set up a proxy with disqus-php-api in a host which sets between the client browser and the Disqus server. The idea is that if Disqus can be reached in the guest network, the blog page will show the original Disqus comments UI, otherwise, it will downgrade and use the proxy to access the Disqus, the UI will be a little different, but the visitors can still write their comments on the page.\nThe client side java script has already been integrated to CleanWhite them, but you need to set up a proxy server yourself.\nThe proxy is written in php, which can be found here: https://github.com/zhaohuabing/disqus-php-api/tree/master/api\nYou need to specify your Disqus account information in the config.php.\ndefine(\u0026#39;PUBLIC_KEY\u0026#39;, \u0026#39;\u0026#39;); define(\u0026#39;SECRET_KEY\u0026#39;, \u0026#39;\u0026#39;); define(\u0026#39;DISQUS_USERNAME\u0026#39;, \u0026#39;\u0026#39;); define(\u0026#39;DISQUS_EMAIL\u0026#39;, \u0026#39;\u0026#39;); define(\u0026#39;DISQUS_PASSWORD\u0026#39;, \u0026#39;\u0026#39;); define(\u0026#39;DISQUS_WEBSITE\u0026#39;, \u0026#39;\u0026#39;); define(\u0026#39;DISQUS_SHORTNAME\u0026#39;, \u0026#39;\u0026#39;); Set the proxy server address in the site config file of your Hugo project.\ndisqus_proxy = \u0026#34;http://yourdisqusproxy.com\u0026#34; Site Search with Algolia Follow this tutorial to create your index in Algolia. The index is just the storage of the indexing data of your site in the the cloud . The search page of CleanWhite theme will utilize this indexing data to do the search.\nGo to the directory where you have your Hugo site and run the following commands:\n$ npm init $ npm install atomic-algolia --save Next, open up the newly created package.json, where we’ll add an NPM script to update your index at Algolia. Find \u0026ldquo;scripts\u0026rdquo;, and add the following:\n\u0026#34;algolia\u0026#34;: \u0026#34;atomic-algolia\u0026#34; Algolia index output format has already been supported by the CleanWhite theme, so you can just build your site, then you’ll find a file called algolia.json in the root, which we can use to update your index in Algolia. Generate index file:\n$ hugo Create a new file in the root of your Hugo project called .env, and add the following contents:\nALGOLIA_APP_ID={{ YOUR_APP_ID }} ALGOLIA_ADMIN_KEY={{ YOUR_ADMIN_KEY }} ALGOLIA_INDEX_NAME={{ YOUR_INDEX_NAME }} ALGOLIA_INDEX_FILE={{ PATH/TO/algolia.json }} Now you can push your index to Algolia by simply running:\n$ npm run algolia Add the following variables to your hugo site config so the search page can get access to algolia index data in the cloud:\nalgolia_search = true algolia_appId = {{ YOUR_APP_ID }} algolia_indexName = {{ YOUR_INDEX_NAME }} algolia_apiKey = {{ YOUR_SEARCH_ONLY_KEY }} Open search page in your browser: http://localhost:1313/search\nAnalytics You can optionally enable Google or Baidu Analytics. Type your tracking code in the\ngoogleAnalytics = \u0026#34;G-XXXXX\u0026#34; ba_track_id = \u0026#34;XXXXXXXXXXXXXXXX\u0026#34; Leave the googleAnalytics or \u0026lsquo;ba_track_id \u0026rsquo; key empty to disable it.\nWechat Pay \u0026amp; Alipay Rewards You can enable Wechat Pay \u0026amp; Alipay to allow readers send you money. So if they like your articles, you may even get rewards from your writing. Now you must be motivated to write more.\nEnable Wechat Pay \u0026amp; Alipay in the site config reward = true Replace the QR codes of Wechat Pay \u0026amp; Alipay by overriding the photos in folder /static/img/reward/, otherwise the money will be sent to my accounts! Thank Thanks for the great jobs of huxblog Jekyll Theme and Clean Blog Jekyll Theme which are the the two upstream projects CleanWhite Hugo theme is based on.\nFeedback If you find any problems, please feel free to raise an issue or create a pull request to fix it.\nIf it\u0026rsquo;s helpful for you, I would appreciate it if you could star this repository, thanks!\n","date":"2019-01-09T00:00:00Z","permalink":"https://helloworld-mjj.github.io/post/readme/","section":"post","tags":["Istio"],"title":"Clean White Theme for Hugo"},{"categories":null,"contents":"到目前为止，Istio提供了一个简单的API来进行流量管理，该API包括了四种资源：RouteRule，DestinationPolicy，EgressRule和Ingress（直接使用了Kubernets的Ingress资源）。借助此API，用户可以轻松管理Istio服务网格中的流量。该API允许用户将请求路由到特定版本的服务，为弹性测试注入延迟和失败，添加超时和断路器等等，所有这些功能都不必更改应用程序本身的代码。\n虽然目前API的功能已被证明是Istio非常引人注目的一部分，但用户的反馈也表明，这个API确实有一些缺点，尤其是在使用它来管理包含数千个服务的非常大的应用程序，以及使用HTTP以外的协议时。 此外，使用Kubernetes Ingress资源来配置外部流量的方式已被证明不能满足需求。\n为了解决上述缺陷和其他的一些问题，Istio引入了新的流量管理API v1alpha3，新版本的API将完全取代之前的API。 尽管v1alpha3和之前的模型在本质上是基本相同的，但它并不向后兼容的，基于旧API的模型需要进行手动转换。 Istio接下来的几个版本中会提供一个新旧模型的转换工具。\n为了证明该非兼容升级的必要性，v1alpha3 API经历了漫长而艰苦的社区评估过程，以希望新的API能够大幅改进，并经得起时间考验。 在本文中，我们将介绍新的配置模型，并试图解释其后面的一些动机和设计原则。\n设计原则 路由模型的重构过程中遵循了一些关键的设计原则：\n除支持声明式（意图）配置外，也支持显式指定模型依赖的基础设施。例如，除了配置入口网关（的功能特性）之外，负责实现 入口网关功能的组件（Controller）也可以在模型指定。 编写模型时应该“生产者导向”和“以Host为中心”，而不是通过组合多个规则来编写模型。 例如，所有与特定Host关联的规则被配置在一起，而不是单独配置。 将路由与路由后行为清晰分开。 v1alpha3中的配置资源 在一个典型的网格中，通常有一个或多个用于终结外部TLS链接，将流量引入网格的负载均衡器（我们称之为gateway）。 然后流量通过边车网关（sidecar gateway）流经内部服务。 应用程序使用外部服务的情况也很常见（例如访问Google Maps API），一些情况下，这些外部服务可能被直接调用；但在某些部署中，网格中所有访问外部服务的流量可能被要求强制通过专用的出口网关（Egress gateway）。 下图描绘了网关在网格中的使用情况。\n考虑到上述因素，v1alpha3引入了以下这些新的配置资源来控制进入网格，网格内部和离开网格的流量路由。\nGateway VirtualService DestinationRule ServiceEntry VirtualService，DestinationRule和ServiceEntry分别替换了原API中的RouteRule，DestinationPolicy和EgressRule。 Gateway是一个独立于平台的抽象，用于对流入专用中间设备的流量进行建模。\n下图描述了跨多个配置资源的控制流程。 Gateway Gateway用于为HTTP / TCP流量配置负载均衡器，并不管该负载均衡器将在哪里运行。 网格中可以存在任意数量的Gateway，并且多个不同的Gateway实现可以共存。 实际上，通过在配置中指定一组工作负载（Pod）标签，可以将Gateway配置绑定到特定的工作负载，从而允许用户通过编写简单的Gateway Controller来重用现成的网络设备。\n对于入口流量管理，您可能会问： 为什么不直接使用Kubernetes Ingress API ？ 原因是Ingress API无法表达Istio的路由需求。 Ingress试图在不同的HTTP代理之间取一个公共的交集，因此只能支持最基本的HTTP路由，最终导致需要将代理的其他高级功能放入到注解（annotation）中，而注解的方式在多个代理之间是不兼容的，无法移植。\nIstio Gateway 通过将L4-L6配置与L7配置分离的方式克服了Ingress的这些缺点。 Gateway只用于配置L4-L6功能（例如，对外公开的端口，TLS配置），所有主流的L7代理均以统一的方式实现了这些功能。 然后，通过在Gateway上绑定VirtualService的方式，可以使用标准的Istio规则来控制进入Gateway的HTTP和TCP流量。\n例如，下面这个简单的Gateway配置了一个Load Balancer，以允许访问host bookinfo.com的https外部流量入mesh中：\napiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: bookinfo-gateway spec: servers: - port: number: 443 name: https protocol: HTTPS hosts: - bookinfo.com tls: mode: SIMPLE serverCertificate: /tmp/tls.crt privateKey: /tmp/tls.key 要为进入上面的Gateway的流量配置相应的路由，必须为同一个host定义一个VirtualService（在下一节中描述），并使用配置中的gateways字段绑定到前面定义的Gateway 上：\napiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: bookinfo spec: hosts: - bookinfo.com gateways: - bookinfo-gateway # \u0026lt;---- bind to gateway http: - match: - uri: prefix: /reviews route: ... Gateway可以用于建模边缘代理或纯粹的内部代理，如第一张图所示。 无论在哪个位置，所有网关都可以用相同的方式进行配置和控制。\nVirtualService 用一种叫做“Virtual services”的东西代替路由规则可能看起来有点奇怪，但对于它配置的内容而言，这事实上是一个更好的名称，特别是在重新设计API以解决先前模型的可扩展性问题之后。\n实际上，发生的变化是：在之前的模型中，需要用一组相互独立的配置规则来为特定的目的服务设置路由规则，并通过precedence字段来控制这些规则的顺序；在新的API中，则直接对（虚拟）服务进行配置，该虚拟服务的所有规则以一个有序列表的方式配置在对应的VirtualService 资源中。\n例如，之前在Bookinfo 应用程序的reviews服务中有两个RouteRule资源，如下所示：\napiVersion: config.istio.io/v1alpha2 kind: RouteRule metadata: name: reviews-default spec: destination: name: reviews precedence: 1 route: - labels: version: v1 --- apiVersion: config.istio.io/v1alpha2 kind: RouteRule metadata: name: reviews-test-v2 spec: destination: name: reviews precedence: 2 match: request: headers: cookie: regex: \u0026#34;^(.*?;)?(user=jason)(;.*)?$\u0026#34; route: - labels: version: v2 在v1alph3，可以在单个VirtualService资源中提供相同的配置：\napiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: reviews spec: hosts: - reviews http: - match: - headers: cookie: regex: \u0026#34;^(.*?;)?(user=jason)(;.*)?$\u0026#34; route: - destination: host: reviews subset: v2 - route: - destination: host: reviews subset: v1 正如你所看到的， 和reviews服务相关的两个规则集中写在了一个地方。这个改变乍一看可能觉得并没有什么特别的优势， 然而，如果仔细观察这个新模型，会发现它和之前的API之间存在着根本的差异，这使得v1alpha3功能更加强大。\n首先，请注意VirtualService的目标服务是使用hosts字段（实际上是重复字段）指定的，然后再在每个路由的destination字段中指定。 这是与以前模型的重要区别。\nVirtualService描述了一个或多个用户可寻址目标到网格内实际工作负载之间的映射。在上面的示例中，这两个地址是相同的，但实际上用户可寻址目标可以是任何用于定位服务的，具有可选通配符前缀或CIDR前缀的DNS名称。 这对于应用从单体架构到微服务架构的迁移过程特别有用，单体应用被拆分为多个独立的微服务后，采用VirtaulService可以继续把多个微服务对外暴露为同一个目标地址，而不需要服务消费者进行修改以适应该变化。\n例如，以下规则允许服务消费者访问Bookinfo应用程序的reviews和ratings服务，就好像它们是http://bookinfo.com/（虚拟）服务的一部分：\napiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: bookinfo spec: hosts: - bookinfo.com http: - match: - uri: prefix: /reviews route: - destination: host: reviews - match: - uri: prefix: /ratings route: - destination: host: ratings ... 实际上在｀VirtualService｀中hosts部分设置只是虚拟的目的地,因此不一定是已在网格中注册的服务。这允许用户为在网格内没有可路由条目的虚拟主机的流量进行建模。 通过将VirtualService绑定到同一Host的Gateway配置（如前一节所述 ），可向网格外部暴露这些Host。\n除了这个重大的重构之外， VirtualService还包括其他一些重要的改变：\n可以在VirtualService配置中表示多个匹配条件，从而减少对冗余的规则设置。\n每个服务版本都有一个名称（称为服务子集）。 属于某个子集的一组Pod/VM在DestinationRule定义，具体定义参见下节。\n通过使用带通配符前缀的DNS来指定VirtualService的host，可以创建单个规则以作用于所有匹配的服务。 例如，在Kubernetes中，在\u0026rsquo;VirtualService\u0026rsquo;中使用*.foo.svc.cluster.local作为host,可以对foo命名空间中的所有服务应用相同的重写规则。\nDestinationRule DestinationRule配置将流量转发到服务时应用的策略集。 这些策略应由由服务提供者撰写，用于描述断路器，负载均衡设置，TLS设置等。 除了下述改变外，DestinationRule与其前身DestinationPolicy大致相同。\nDestinationRule的host可以包含通配符前缀，以允许单个规则应用于多个服务。 DestinationRule定义了目的host的子集subsets （例如：命名版本）。 这些subset用于｀VirtualService｀的路由规则设置中，可以将流量导向服务的某些特定版本。 通过这种方式为版本命名后，可以在不同的virtual service中明确地引用这些命名版本的ubset，简化Istio代理发出的统计数据，并可以将subsets编码到SNI头中。 为reviews服务配置策略和subsets的DestinationRule可能如下所示： apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: reviews spec: host: reviews trafficPolicy: loadBalancer: simple: RANDOM subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 trafficPolicy: loadBalancer: simple: ROUND_ROBIN - name: v3 labels: version: v3 注意，与DestinationPolicy不同的是，可在单个DestinationRule中指定多个策略（例如上面实例中的缺省策略和v2版本特定的策略）。\nServiceEntry ServiceEntry用于将附加条目添加到Istio内部维护的服务注册表中。 它最常用于对访问网格外部依赖的流量进行建模，例如访问Web上的API或遗留基础设施中的服务。\n所有以前使用EgressRule进行配置的内容都可以通过ServiceEntry轻松完成。 例如，可以使用类似这样的配置来允许从网格内部访问一个简单的外部服务：\napiVersion: networking.istio.io/v1alpha3 kind: ServiceEntry metadata: name: foo-ext spec: hosts: - foo.com ports: - number: 80 name: http protocol: HTTP 也就是说，ServiceEntry比它的前身具有更多的功能。首先，ServiceEntry不限于外部服务配置，它可以有两种类型：网格内部或网格外部。网格内部条目只是用于向网格显式添加服务，添加的服务与其他内部服务一样。采用网格内部条目，可以把原本未被网格管理的基础设施也纳入到网格中（例如，把虚机中的服务添加到基于Kubernetes的服务网格中）。网格外部条目则代表了网格外部的服务。对于这些外部服务来说，mTLS身份验证是禁用的，并且策略是在客户端执行的，而不是在像内部服务请求一样在服务器端执行策略。\n由于ServiceEntry配置只是将服务添加到网格内部的服务注册表中，因此它可以像注册表中的任何其他服务一样,与VirtualService和/或DestinationRule一起使用。例如，以下DestinationRule可用于启动外部服务的mTLS连接：\napiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: foo-ext spec: name: foo.com trafficPolicy: tls: mode: MUTUAL clientCertificate: /etc/certs/myclientcert.pem privateKey: /etc/certs/client_private_key.pem caCertificates: /etc/certs/rootcacerts.pem 除了扩展通用性以外，ServiceEntry还提供了其他一些有关EgressRule改进，其中包括：\n一个ServiceEntry可以配置多个服务端点，这在之前需要采用多个EgressRules来实现。 现在可以配置服务端点的解析模式（NONE，STATIC或DNS）。 此外，我们正在努力解决另一个难题：目前需要通过纯文本端口访问安全的外部服务（例如http://google.com:443）。该问题将会在未来几周内得到解决，届时将允许从应用程序直接访问https://google.com。请继续关注解决此限制的Istio补丁版本（0.8.x）。 创建和删除v1alpha3路由规则 由于一个特定目的地的所有路由规则现在都存储在单个VirtualService资源的一个有序列表中，因此为该目的地添加新的规则不需要再创建新的RouteRule，而是通过更新该目的地的VirtualService资源来实现。\n旧的路由规则：\n$ istioctl create -f my-second-rule-for-destination-abc.yaml v1alpha3路由规则：\n$ istioctl replace -f my-updated-rules-for-destination-abc.yaml 删除路由规则也使用istioctl replace完成，当然删除最后一个路由规则除外（删除最后一个路由规则需要删除VirtualService）。\n在添加或删除引用服务版本的路由时，需要在该服务相应的DestinationRule更新subsets 。 正如你可能猜到的，这也是使用istioctl replace完成的。\n总结 Istio v1alpha3路由API具有比其前身更多的功能，但不幸的是新的API并不向后兼容，旧的模型升级需要一次手动转换。 Istio 0.9以后将不再支持RouteRule，DesintationPolicy和EgressRule这些以前的配置资源 。Kubernetes用户可以继续使用Ingress配置边缘负载均衡器来实现基本的路由。 但是，高级路由功能（例如，跨两个版本的流量分割）则需要使用Gateway ，这是一种功能更强大，Istio推荐的Ingress替代品。\n致谢 感谢以下人员为新版本的路由模型重构和实现工作做出的贡献（按字母顺序）\nFrank Budinsky (IBM) Zack Butcher (Google) Greg Hanson (IBM) Costin Manolache (Google) Martin Ostrowski (Google) Shriram Rajagopalan (VMware) Louis Ryan (Google) Isaiah Snell-Feikema (IBM) Kuat Yessenov (Google) 原文 Introducing the Istio v1alpha3 routing API ","date":"2018-06-04T00:00:00Z","permalink":"https://helloworld-mjj.github.io/2018/06/04/introducing-the-istio-v1alpha3-routing-api/","section":"post","tags":["Istio"],"title":"Istio v1aplha3 routing API介绍(译文）"},{"categories":null,"contents":"关于我 ","date":"0001-01-01T00:00:00Z","permalink":"https://helloworld-mjj.github.io/about/","section":"","tags":null,"title":""},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://helloworld-mjj.github.io/search/placeholder/","section":"search","tags":null,"title":""},{"categories":null,"contents":"","date":"0001-01-01T00:00:00Z","permalink":"https://helloworld-mjj.github.io/archive/","section":"","tags":null,"title":"Posts Archive"}]